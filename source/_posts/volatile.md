title: volatile“可见性”理解
categories: 编程
tags: Java
date: 2016-01-29 21:49:46
---

volatile这个关键字我一直没机会用，一般能用synchronized我就用synchronized了。volatile关键字可以保证所有线程对变量的“可见性”，即当一个线程修改一个共享变量时，其它线程能够读到这个最新的值。我当时以为我懂了，后来发现我错了。为了介绍“可见性”，我们先简单说一下Java的内存模型。
<!-- more -->

## Java内存模型

Java为了跨平台，有自己的内存模型，可以屏蔽不同操作系统带来的内存访问差异。Java内存模型分为两块：**主内存和工作内存**。主内存可以想象成是一块儿公共的内存，工作内存则类似处理器的高速缓存且每个线程只能访问自己的工作内存，不能直接访问主内存，比如线程想要读取主内存中的一个变量，需要将该变量加载到自己的工作内存，然后才能读取。

工作内存和主内存之间数据交互有8种操作：

	1. lock: 作用于主内存，锁住主内存变量，使得只有一条线程能访问该变量
	2. unlock：作用于主内存，释放主内存变量，使得其他线程可以访问该变量
	3. read：作用于主内存，把主内存变量读到工作内存中
	4. load：作用于工作内存，把read操作从主内存得到的变量加载到工作内存
	5. use：作用于工作内存，把工作内存中的变量传递给执行引擎
	6. assign：作用于工作内存，将执行引擎中的变量赋值给工作内存
	7. store：作用于工作内存，将工作内存中的变量传送到主内存
	8. write： 作用于主内存，把store操作中得到的变量写入主内存

可以重点看看lock、unlock、load、store这4种。一般的共享变量（没有用volatile修饰的），线程A从主内存读到它，然后在自己的工作内存修改，但是还没有写回到主内存，这时候线程B也从主内存读到它，这个时候读到的就是旧的值。volatile关键字就可以解决这个问题。

## volatile关键字

如果一个变量被声明成volatile，线程A修改了它，线程B去主内存读该变量时，能保证读到的变量是修改后的，即该变量对线程B也是可见的。

再稍微深入一点点分析的话，那就是底层的指令能保证“对该变量进行写操作后，会将工作内存中的值写入主内存，并让其他线程工作内存中该变量失效，这样其他线程想要访问该变量时只能重新从主内存中加载”，从而保证了其他线程读到的变量也是最新的。

volatile还有另外一层语义，即“禁止指令重排序”，这个以后再说。

以上内容参考《深入理解Java虚拟机-JVM高级特性与最佳实践 第二版》，好书，我读了第二遍才读出味来。